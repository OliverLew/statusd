#!/usr/bin/env python3
"""
Update dwm status
Dependency:
    Colors depends on my status color patch
    Clickable status depends on my statuscmd patch
    See https://github.com/OliverLew/dwm
"""

import glob
import os
import signal
import subprocess
import sys
import threading
import time
from mpd import MPDClient
from pyalsa import alsamixer
from Xlib import display


def notify(summary, body=None, icon=None, value=None, urgency=None, timeout=3):
    cmd = ['notify-send', summary, '-t', str(int(timeout * 1000))]
    cmd.extend(['-h', 'string:category:dwm-status'])
    if urgency:
        cmd.extend(['-h', f"byte:urgency:{urgency}"])
    if icon:
        cmd.extend(['-h', f"string:image-path:{icon}"])
    if value:
        cmd.extend(['-h', f"int:value:{value}"])
    if body:
        cmd.append(body)
    subprocess.run(cmd)


class Status:
    def __init__(self, segments):
        self.dpy = display.Display()
        self.root = self.dpy.screen().root

        self.stopped = threading.Event()
        self.status = []
        self.threads = []
        for segment in segments:
            index = len(self.status)
            t = threading.Thread(target=self.update(index, segment))
            self.threads.append(t)
            self.status.append("")
            t.start()
        signal.signal(signal.SIGINT, self.stop)
        signal.signal(signal.SIGTERM, self.stop)
        # for sig in range(signal.SIGRTMIN, signal.SIGRTMAX + 1):
        #     signal.signal(sig, stat.handler)

        self.pidfile = '/tmp/status.pid'
        with open(self.pidfile, 'w') as pidfile:
            pidfile.write(str(os.getpid()))

    def update(self, i, segment):
        def func():
            while not self.stopped.is_set():
                time.sleep(segment.interval)
                fmts = segment.run()
                segstr = segment.fmtstr.format_map(fmts)
                if len(segment.icons) > 0:
                    segstr = segment.icons[0] + segstr
                segstr = f"\001{segstr}\017"
                self.status[i] = segstr
        return func

    def show(self):
        status_text = ' ' + ' '.join(self.status) + ' '
        self.root.set_wm_name(status_text.encode())
        self.dpy.sync()

    def run(self):
        while not self.stopped.is_set():
            time.sleep(1)
            self.show()

    def stop(self, number, frame):
        self.stopped.set()
        for t in self.threads:
            t.join()
        os.remove(self.pidfile)


class Segment:
    def __init__(self, fmt, interval=1, icons=[]):
        self.interval = interval
        self.fmtstr = fmt
        self.icons = icons


class ALSA(Segment):
    def __init__(self, fmt, interval=1, icons=[]):
        super().__init__(fmt, interval, icons)
        self.mixer = alsamixer.Mixer()
        self.mixer.attach()
        self.mixer.load()
        self.alsa = alsamixer.Element(self.mixer, 'Master')
        self.alsa_range = self.alsa.get_volume_range()

    def run(self):
        volumes = self.alsa.get_volume_array()
        volumes = [v * 100 / self.alsa_range[1] for v in volumes]
        return {
            'vol': sum(volumes) / len(volumes)
        }


class Backlight(Segment):
    def run(self):
        for light in glob.glob("/sys/class/backlight/*"):
            try:
                current = open(light + "/brightness").read().strip()
                maximum = open(light + "/max_brightness").read().strip()
                return {
                    "backlight": 100.0 * float(current) / float(maximum)
                }
            except (FileNotFoundError, ZeroDivisionError):
                continue


class Battery(Segment):
    def run(self):
        # not done
        for battery in glob.glob("/sys/class/power_supply/BAT*/uevent"):
            uevent = {k: v.strip() for k, v in [line.split('=') for line in open(battery)]}

            status = uevent.get('POWER_SUPPLY_STATUS').lower()
            charge_full = uevent.get('POWER_SUPPLY_CHARGE_FULL')
            charge_now = uevent.get('POWER_SUPPLY_CHARGE_NOW')
            energy_full = uevent.get('POWER_SUPPLY_ENERGY_FULL')
            energy_now = uevent.get('POWER_SUPPLY_ENERGY_NOW')
            capacity = uevent.get('POWER_SUPPLY_CAPACITY')
            voltage_now = uevent.get('POWER_SUPPLY_VOLTAGE_NOW')
            current_now = uevent.get('POWER_SUPPLY_CURRENT_NOW')
            power_now = uevent.get('POWER_SUPPLY_POWER_NOW')
            time_to_empty_now = uevent.get('POWER_SUPPLY_TIME_TO_EMPTY_NOW')
            time_to_full_now = uevent.get('POWER_SUPPLY_TIME_TO_FULL_NOW')

            if capacity:
                perc = float(capacity)
            elif charge_now and charge_full and current_now:
                perc = float(charge_now) / float(charge_full)
            elif energy_now and energy_full and \
                    (power_now or current_now and voltage_now):
                perc = float(energy_now) / float(energy_full)
            else:
                perc = 0

            if power_now:
                power = float(power_now) / 10**6
            elif voltage_now and current_now:
                power = float(current_now) * float(voltage_now) / 10**12
            elif current_now:
                current = float(current_now) / 10**6
            if status == 'charging':
                if time_to_full_now:
                    time = time_to_full_now
                else:
                    time = 0
            elif status == 'discharging' and time_to_empty_now:
                time = time_to_empty_now

        return {
            'perc': perc
        }


class CPU(Segment):
    def run(self):
        line = open("/proc/stat").readline()
        cols = [float(c) for c in line.split()[1:]]
        idle = cols[3] + cols[4]
        total = sum(cols)

        try:
            diff_idle = idle - self.idle_old
            diff_total = total - self.total_old
            perc = (1 - diff_idle / diff_total) * 100
        except (ZeroDivisionError, AttributeError):
            perc = 0

        self.idle_old = idle
        self.total_old = total
        return {
            'cpu_idle': idle,
            'cpu_total': total,
            'perc': perc
        }


class Date(Segment):
    def run(self):
        return {'date': time.strftime("%a %b %d %H:%M:%S")}


class Memory(Segment):
    def run(self):
        meminfo = [line.split(':') for line in open('/proc/meminfo')]
        mem = {k: int(v.strip().split()[0]) for k, v in meminfo}
        return {
            'used': mem['MemTotal'] - mem['MemAvailable'],
            'total': mem['MemTotal'],
            'perc': 100 * (mem['MemTotal'] - mem['MemAvailable']) / mem['MemTotal'],
            'swap_used': mem['SwapTotal'] - mem['SwapFree'],
            'swap_total': mem['SwapTotal'],
            'swap_perc': 100 * (mem['SwapTotal'] - mem['SwapFree']) / mem['SwapTotal']
        }


class Mpd(Segment):
    def __init__(self, fmt, interval=1, icons=[]):
        super().__init__(fmt, interval, icons)
        self.mpdclient = MPDClient()
        self.mpdclient.connect("localhost", 6600)

    def run(self):
        currentsong = self.mpdclient.currentsong()
        status = self.mpdclient.status()
        return {
            'song': currentsong.get('file', ''),
            'time': float(currentsong.get('time', 0)),
            'elapsed': float(status.get('elapsed', 0)),
            'status': status.get('state', '')
        }


class Power(Segment):
    def run(self):
        for status in glob.glob("/sys/class/power_supply/A*/online"):
            if open(status).readline().strip() == '1':
                return {'power': 1}
            else:
                return {'power': 0}


if __name__ == '__main__':
    if len(sys.argv) > 1:
        notify("Button:{},pos:{}".format(os.getenv("BUTTON"), sys.argv[1]))
        exit()

    Status([
        Memory("{perc:2.0f}", icons=['󰍛']),
        CPU("{perc:2.0f}", icons=['󰓅']),
        ALSA("alsa:{vol:2.0f}"),
        Backlight("{backlight:2.0f}", icons=['󰃟']),
        Mpd("{status}", icons=['󰝚']),
        Power("power:{power}"),
        Battery("bat:{perc:2.0f}"),
        Date("{date}", icons=["󰃰"]),
    ]).run()
