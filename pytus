#!/usr/bin/env python3
import os
import glob
import time
import signal
import threading
from pyalsa import alsamixer
from Xlib import display


def color(string, fg, bg):
    return ""


def notify(summary, body=None, icon=None, value=None, urgency=None, timeout=3):
    cmd = ['notify-send', summary, '-t', str(int(timeout * 1000))]
    cmd.extend(['-h', 'string:category:dwm-status'])
    if urgency:
        cmd.extend(['-h', f"byte:urgency:{urgency}"])
    if icon:
        cmd.extend(['-h', f"string:image-path:{icon}"])
    if value:
        cmd.extend(['-h', f"int:value:{value}"])
    if body:
        cmd.append(body)
    # subprocess.run(cmd)
    print(cmd)


class loop(object):
    """ loop a function, can be used as a decorator: @loop(seconds) """

    def __init__(self, interval):
        self.interval = interval

    def __call__(self, function):
        def loopfunc(*args):
            while not stop_event.is_set():
                time.sleep(self.interval)
                function(*args)
        return loopfunc


class Status:
    def __init__(self):
        self.dpy = display.Display()
        self.root = self.dpy.screen().root

        self.mixer = alsamixer.Mixer()
        self.mixer.attach()
        self.mixer.load()
        self.alsa = alsamixer.Element(self.mixer, 'Master')
        self.alsa_range = self.alsa.get_volume_range()

        self.cache = dict()
        self.status = dict()

    def xsetroot_name(self, name):
        print("window name: " + name)
        # self.root.set_wm_name(name)
        # self.dpy.sync()

    def power(self):
        for status in glob.glob("/sys/class/power_supply/A*/online"):
            if open(status).readline().strip() == '1':
                self.status['power'] = 1
                break

    def battery(self):
        # not done
        for battery in glob.glob("/sys/class/power_supply/BAT*/uevent"):
            uevent = {k: v.strip() for k, v in [line.split('=') for line in open(battery)]}

            status = uevent.get('POWER_SUPPLY_STATUS').lower()
            charge_full = uevent.get('POWER_SUPPLY_CHARGE_FULL')
            charge_now = uevent.get('POWER_SUPPLY_CHARGE_NOW')
            energy_full = uevent.get('POWER_SUPPLY_ENERGY_FULL')
            energy_now = uevent.get('POWER_SUPPLY_ENERGY_NOW')
            capacity = uevent.get('POWER_SUPPLY_CAPACITY')
            voltage_now = uevent.get('POWER_SUPPLY_VOLTAGE_NOW')
            current_now = uevent.get('POWER_SUPPLY_CURRENT_NOW')
            power_now = uevent.get('POWER_SUPPLY_POWER_NOW')
            time_to_empty_now = uevent.get('POWER_SUPPLY_TIME_TO_EMPTY_NOW')
            time_to_full_now = uevent.get('POWER_SUPPLY_TIME_TO_FULL_NOW')

            if capacity:
                perc = int(capacity)
            elif charge_now and charge_full and current_now:
                perc = int(float(charge_now) / float(charge_full))
            elif energy_now and energy_full and \
                    (power_now or current_now and voltage_now):
                perc = int(float(energy_now) / float(energy_full))
            else:
                perc = 0

            self.status['battery'] = perc

            if power_now:
                power = float(power_now) / 10**6
            elif voltage_now and current_now:
                power = float(current_now) * float(voltage_now) / 10**12
            elif current_now:
                current = float(current_now) / 10**6
            if status == 'charging':
                if time_to_full_now:
                    time = time_to_full_now
                else:
                    time = 0
            elif status == 'discharging' and time_to_empty_now:
                time = time_to_empty_now
                time_to_empty_now

    def cpu(self):
        for line in open("/proc/stat"):
            if line.split()[0] == "cpu":
                cols = [float(c) for c in line.split()[1:]]
                idle = cols[3] + cols[4]
                total = sum(cols)
                break

        try:
            diff_idle = idle - self.cache['idle']
            diff_total = total - self.cache['total']
            perc = (1 - diff_idle / diff_total) * 100
        except (ZeroDivisionError, KeyError):
            perc = 0

        self.cache['idle'] = idle
        self.cache['total'] = total
        self.status['cpu'] = perc

    def imap(self):
        # with IMAP4_SSL()
        pass

    def memory(self):
        meminfo = [line.split(':') for line in open('/proc/meminfo')]
        mem = {k: int(v.strip().split()[0]) for k, v in meminfo}
        self.status['mem_used'] = mem['MemTotal'] - mem['MemAvailable']
        self.status['mem_total'] = mem['MemTotal']
        self.status['mem_perc'] = 100 * self.status['mem_used'] / mem['MemTotal']
        self.status['swap_used'] = mem['SwapTotal'] - mem['SwapFree']
        self.status['swap_total'] = mem['SwapTotal']
        self.status['swap_perc'] = 100 * self.status['swap_used'] / mem['SwapTotal']


    def network(self):
        pass

    def volume(self):
        volumes = self.alsa.get_volume_array()
        volumes = [v * 100 / self.alsa_range[1] for v in volumes]
        self.status['vol'] = sum(volumes) / len(volumes)

    def brightness(self):
        for light in glob.glob("/sys/class/backlight/*"):
            try:
                current = open(light + "/brightness").read().strip()
                maximum = open(light + "/max_brightness").read().strip()
                self.status['bl'] = 100.0 * float(current) / float(maximum)
            except (FileNotFoundError, ZeroDivisionError):
                continue

    def mpd(self):
        pass

    def date(self):
        self.status['datetime'] = time.strftime("%a %b %d %H:%M:%S")

    def test(self):
        fmt = "mem:{mem:.0f} cpu:{cpu:.0f} vol:{vol:.0f} bl:{bl:.0f} bat:{bat:.0f}"
        self.xsetroot_name(fmt.format(
            mem=self.status.get('mem_perc', 0),
            cpu=self.status.get('cpu', 0),
            vol=self.status.get('vol', 0),
            bl=self.status.get('bl', 0),
            bat=self.status.get('battery', 0),
        ) + self.status.get('datetime', ''))

    def handler(self, number, frame):
        n = number - signal.SIGRTMIN
        notify(str(self.status) + f' {n}')

    def clean_up(self, number, frame):
        stop_event.set()


class date:
    def run(self):
        return time.strftime("%a %b %d %H:%M:%S")


segments = {
    'date': '󰃰',
    'notification': '󰂞',
    'exec': '󰣖',
    'apps': '󰍉',
    'mpd': '󰝚',
    'brightness': '󰃟',
    'mail': '󰇰',
    'memory': '󰍛',
    'cpu': '󰓅',
    'play': ['󰏤', '󰐊', '󰓛']
}


if __name__ == '__main__':
    segments = [
        date,
    ]

    with open('/tmp/status.pid', 'w') as pidfile:
        pidfile.write(str(os.getpid()))

    stop_event = threading.Event()
    stat = Status()

    for sig in range(signal.SIGRTMIN, signal.SIGRTMAX + 1):
        signal.signal(sig, stat.handler)
    signal.signal(signal.SIGTERM, stat.clean_up)
    signal.signal(signal.SIGINT, stat.clean_up)

    threads = [
        threading.Thread(target=loop(1)(stat.battery), args=()),
        threading.Thread(target=loop(1)(stat.brightness), args=()),
        threading.Thread(target=loop(1)(stat.cpu), args=()),
        threading.Thread(target=loop(1)(stat.date), args=()),
        threading.Thread(target=loop(1)(stat.memory), args=()),
        threading.Thread(target=loop(1)(stat.power), args=()),
        threading.Thread(target=loop(1)(stat.volume), args=()),
    ]

    for t in threads:
        t.start()

    while not stop_event.is_set():
        stat.test()
        time.sleep(1)

    for t in threads:
        t.join()
    os.remove("/tmp/status.pid")
