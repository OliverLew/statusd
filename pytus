#!/usr/bin/env python3
"""
Update dwm status
Dependency:
    Colors depends on my status color patch
    Clickable status depends on my statuscmd patch
    See https://github.com/OliverLew/dwm
"""

import dbus
import glob
import os
import signal
import sys
import threading
import time
from mpd import MPDClient, base
from pyalsa import alsamixer
from alsaaudio import Mixer
from Xlib import display


class Notification:
    def __init__(self):
        bus_name = "org.freedesktop.Notifications"
        obj_path = "/org/freedesktop/Notifications"
        bus = dbus.SessionBus()
        obj = bus.get_object(bus_name, obj_path)
        interface = dbus.Interface(obj, bus_name)
        self.notify_func = interface.get_dbus_method("Notify")

    def notify(self, summary, body="", icon="", value=None, urgency=1, timeout=3000):
        hints = {"urgency": urgency, "category": "dwm-status"}
        if value:
            hints['value'] = value
        self.notify_func("dwm-status", 0, icon, summary, body, [], hints, timeout)


class Status:
    def __init__(self, segments):
        self.dpy = display.Display()
        self.root = self.dpy.screen().root

        self.stopped = threading.Event()
        self.status = []
        self.threads = []
        for segment in segments:
            index = len(self.status)
            self.status.append("")
            t = threading.Thread(target=self.update(index, segment))
            self.threads.append(t)
            t.start()
        signal.signal(signal.SIGINT, self.stop)
        signal.signal(signal.SIGTERM, self.stop)
        # for sig in range(signal.SIGRTMIN, signal.SIGRTMAX + 1):
        #     signal.signal(sig, stat.handler)

        self.pidfile = '/tmp/status.pid'
        with open(self.pidfile, 'w') as pidfile:
            pidfile.write(str(os.getpid()))

    def update(self, i, segment):
        def func():
            while not self.stopped.is_set():
                time.sleep(segment.interval)
                fmts = segment.run()
                segstr = segment.fmtstr.format_map(fmts)
                if segment.icons:
                    segstr = segment.icons.split()[0] + segstr
                segstr = chr(i + 1) + f"{segstr}" + chr(15)
                self.status[i] = segstr

        if i >= 14:
            notification.notify("At most 14 segments are allowed")
            exit(1)
        return func

    def show(self):
        status_text = ' ' + ' '.join(self.status) + ' '
        self.root.set_wm_name(status_text.encode())
        self.dpy.sync()

    def run(self):
        while not self.stopped.is_set():
            curtime = time.time()
            nextsec = int(curtime + 0.5) + 1
            time.sleep(nextsec - curtime)
            self.show()

    def stop(self, number, frame):
        self.stopped.set()
        for t in self.threads:
            t.join()
        os.remove(self.pidfile)


class Segment:
    def __init__(self, fmt, interval=1, icons=None, color=0, keys={}):
        self.interval = interval
        self.fmtstr = fmt
        self.icons = icons
        self.color = 0
        self.timer = None


class ALSA(Segment):
    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)
        self.mixer = Mixer()
        self.max = self.mixer.getrange()[1]

    def run(self):
        mute = self.mixer.getmute()
        return {
            'vol': self.mixer.getvolume()[0],
            'mute': all(mute)
        }

    def up(self):
        volume = self.mixer.getvolume()[0] + 4
        if volume >= self.max:
            volume = self.max
        self.mixer.setvolume(volume)

    def down(self):
        volume = self.mixer.getvolume()[0] - 4
        if volume < 0:
            volume = 0
        self.mixer.setvolume(volume)


class ALSA2(Segment):
    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)
        self.mixer = alsamixer.Mixer()
        self.mixer.attach()
        self.mixer.load()
        self.alsa = alsamixer.Element(self.mixer, 'Master')
        self.alsa_range = self.alsa.get_volume_range()

    def run(self):
        volume = self.alsa.get_volume()
        return {
            'vol': 100.0 * volume / self.alsa_range[1],
            'active': self.alsa.get_switch()
        }

    def up(self):
        volume = self.alsa.get_volume()
        volume += 0.04 * self.alsa_range[1]
        if volume >= self.alsa_range[1]:
            volume = self.alsa_range[1]
        self.alsa.set_volume_all(volume)

    def down(self):
        volume = self.alsa.get_volume()
        volume -= 0.04 * self.alsa_range[1]
        if volume < 0:
            volume = 0
        self.alsa.set_volume_all(volume)


class Backlight(Segment):
    def run(self):
        for light in glob.glob("/sys/class/backlight/*"):
            try:
                current = open(light + "/brightness").read().strip()
                maximum = open(light + "/max_brightness").read().strip()
                return {
                    "backlight": 100.0 * float(current) / float(maximum)
                }
            except (FileNotFoundError, ZeroDivisionError):
                continue


class Battery(Segment):
    def run(self):
        # not done
        for battery in glob.glob("/sys/class/power_supply/BAT*/uevent"):
            uevent = {k: v.strip() for k, v in [line.split('=') for line in open(battery)]}

            status = uevent.get('POWER_SUPPLY_STATUS').lower()
            charge_full = uevent.get('POWER_SUPPLY_CHARGE_FULL')
            charge_now = uevent.get('POWER_SUPPLY_CHARGE_NOW')
            energy_full = uevent.get('POWER_SUPPLY_ENERGY_FULL')
            energy_now = uevent.get('POWER_SUPPLY_ENERGY_NOW')
            capacity = uevent.get('POWER_SUPPLY_CAPACITY')
            voltage_now = uevent.get('POWER_SUPPLY_VOLTAGE_NOW')
            current_now = uevent.get('POWER_SUPPLY_CURRENT_NOW')
            power_now = uevent.get('POWER_SUPPLY_POWER_NOW')
            time_to_empty_now = uevent.get('POWER_SUPPLY_TIME_TO_EMPTY_NOW')
            time_to_full_now = uevent.get('POWER_SUPPLY_TIME_TO_FULL_NOW')

            if capacity:
                perc = float(capacity)
            elif charge_now and charge_full and current_now:
                perc = float(charge_now) / float(charge_full)
            elif energy_now and energy_full and \
                    (power_now or current_now and voltage_now):
                perc = float(energy_now) / float(energy_full)
            else:
                perc = 0

            if power_now:
                power = float(power_now) / 10**6
            elif voltage_now and current_now:
                power = float(current_now) * float(voltage_now) / 10**12
            elif current_now:
                current = float(current_now) / 10**6
            if status == 'charging':
                if time_to_full_now:
                    time = time_to_full_now
                else:
                    time = 0
            elif status == 'discharging' and time_to_empty_now:
                time = time_to_empty_now

        return {
            'perc': perc
        }


class CPU(Segment):
    def run(self):
        line = open("/proc/stat").readline()
        cols = [float(c) for c in line.split()[1:]]
        idle = cols[3] + cols[4]
        total = sum(cols)

        try:
            diff_idle = idle - self.idle_old
            diff_total = total - self.total_old
            perc = (1 - diff_idle / diff_total) * 100
        except (ZeroDivisionError, AttributeError):
            perc = 0

        self.idle_old = idle
        self.total_old = total
        return {
            'cpu_idle': idle,
            'cpu_total': total,
            'perc': perc
        }


class Date(Segment):
    def run(self):
        return {'date': time.strftime("%a %b %d %H:%M:%S")}


class Memory(Segment):
    def run(self):
        meminfo = [line.split(':') for line in open('/proc/meminfo')]
        mem = {k: int(v.strip().split()[0]) for k, v in meminfo}
        return {
            'used': mem['MemTotal'] - mem['MemAvailable'],
            'total': mem['MemTotal'],
            'perc': 100 * (mem['MemTotal'] - mem['MemAvailable']) / mem['MemTotal'],
            'swap_used': mem['SwapTotal'] - mem['SwapFree'],
            'swap_total': mem['SwapTotal'],
            'swap_perc': 100 * (mem['SwapTotal'] - mem['SwapFree']) / mem['SwapTotal']
        }


class Mpd(Segment):
    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)
        self.mpdclient = MPDClient()
        self.connect()

    def connect(self):
        try:
            self.mpdclient.connect("localhost", 6600)
        except ConnectionRefusedError:
            time.sleep(1)

    def run(self):
        try:
            currentsong = self.mpdclient.currentsong()
            status = self.mpdclient.status()
            return {
                'song': currentsong.get('file', ''),
                'time': float(currentsong.get('time', 0)),
                'elapsed': float(status.get('elapsed', 0)),
                'status': status.get('state', '')
            }
        except base.ConnectionError:
            self.connect()
            return {'song': "", 'time': 0, 'elapsed': 0, 'status': "n/a"}


class Network(Segment):
    def run(self):
        fmts = {'ethernet': 0, 'wlan': 0, 'level': 0}
        netdir = "/sys/class/net"
        for iface in os.listdir(netdir):
            ipath = os.path.join(netdir, iface, "operstate")
            state = open(ipath).readline().strip()
            if iface.startswith('e') and state == "up":
                fmts['ethernet'] = 1
            if iface.startswith('w') and state == "up":
                fmts['wlan'] = 1


class Power(Segment):
    def run(self):
        for status in glob.glob("/sys/class/power_supply/A*/online"):
            if open(status).readline().strip() == '1':
                return {'power': 1}
            else:
                return {'power': 0}


if __name__ == '__main__':
    notification = Notification()
    if len(sys.argv) > 1:
        notification.notify("Button:{},pos:{}".format(os.getenv("BUTTON"), sys.argv[1]))
        exit()

    Status([
        Memory("{perc:2.0f}", icons='󰍛'),
        CPU("{perc:2.0f}", icons='󰓅'),
        ALSA("{vol:2.0f},{mute}", icons='󰕾 󰖁', keys={4: "up", 5: "down"}),
        Backlight("{backlight:2.0f}", icons='󰃟'),
        Mpd("{status}", icons='󰝚'),
        Power("power:{power}"),
        Battery("{perc:2.0f}", icons='󰂎 󰁺 󰁻 󰁼 󰁽 󰁾 󰁿 󰂀 󰂁 󰂂 󰁹'),
        Date("{date}", icons="󰃰"),
    ]).run()
