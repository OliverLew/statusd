#!/usr/bin/env python3
import os
import glob
import time
import signal
import threading
from mpd import MPDClient
from pyalsa import alsamixer
from Xlib import display


def color(string, fg, bg):
    return ""


def notify(summary, body=None, icon=None, value=None, urgency=None, timeout=3):
    cmd = ['notify-send', summary, '-t', str(int(timeout * 1000))]
    cmd.extend(['-h', 'string:category:dwm-status'])
    if urgency:
        cmd.extend(['-h', f"byte:urgency:{urgency}"])
    if icon:
        cmd.extend(['-h', f"string:image-path:{icon}"])
    if value:
        cmd.extend(['-h', f"int:value:{value}"])
    if body:
        cmd.append(body)
    # subprocess.run(cmd)
    print(cmd)


class Status2:
    def __init__(self, segments):
        self.dpy = display.Display()
        self.root = self.dpy.screen().root

        self.status = []
        self.threads = []
        self.stopped = threading.Event()
        for segment in segments:
            index = len(self.status)
            func = self.loop(index, segment.interval, segment.run)
            t = threading.Thread(target=func)
            self.threads.append(t)
            self.status.append("")
            t.start()
        signal.signal(signal.SIGINT, self.stop)
        signal.signal(signal.SIGTERM, self.stop)

    def loop(self, i, interval, function):
        def loopfunc():
            while not self.stopped.is_set():
                time.sleep(interval)
                self.status[i] = function()
        return loopfunc

    def show(self):
        print(' '.join(self.status))
        # self.root.set_wm_name(' '.join(self.status))
        # self.dpy.sync()

    def stop(self, number, frame):
        self.stopped.set()
        for t in self.threads:
            t.join()


class ALSA:
    def __init__(self, fmt="{vol}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt

        self.mixer = alsamixer.Mixer()
        self.mixer.attach()
        self.mixer.load()
        self.alsa = alsamixer.Element(self.mixer, 'Master')
        self.alsa_range = self.alsa.get_volume_range()

    def run(self):
        volumes = self.alsa.get_volume_array()
        volumes = [v * 100 / self.alsa_range[1] for v in volumes]
        fmts = {
            'vol': sum(volumes) / len(volumes)
        }
        return self.fmtstr.format_map(fmts)


class Backlight:
    def __init__(self, fmt="{backlight}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt

    def run(self):
        for light in glob.glob("/sys/class/backlight/*"):
            try:
                current = open(light + "/brightness").read().strip()
                maximum = open(light + "/max_brightness").read().strip()
                fmts = {
                    "backlight": 100.0 * float(current) / float(maximum)
                }
            except (FileNotFoundError, ZeroDivisionError):
                continue

        return self.fmtstr.format_map(fmts)


class Battery:
    def __init__(self, fmt="{perc}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt

    def run(self):
        # not done
        for battery in glob.glob("/sys/class/power_supply/BAT*/uevent"):
            uevent = {k: v.strip() for k, v in [line.split('=') for line in open(battery)]}

            status = uevent.get('POWER_SUPPLY_STATUS').lower()
            charge_full = uevent.get('POWER_SUPPLY_CHARGE_FULL')
            charge_now = uevent.get('POWER_SUPPLY_CHARGE_NOW')
            energy_full = uevent.get('POWER_SUPPLY_ENERGY_FULL')
            energy_now = uevent.get('POWER_SUPPLY_ENERGY_NOW')
            capacity = uevent.get('POWER_SUPPLY_CAPACITY')
            voltage_now = uevent.get('POWER_SUPPLY_VOLTAGE_NOW')
            current_now = uevent.get('POWER_SUPPLY_CURRENT_NOW')
            power_now = uevent.get('POWER_SUPPLY_POWER_NOW')
            time_to_empty_now = uevent.get('POWER_SUPPLY_TIME_TO_EMPTY_NOW')
            time_to_full_now = uevent.get('POWER_SUPPLY_TIME_TO_FULL_NOW')

            if capacity:
                perc = capacity
            elif charge_now and charge_full and current_now:
                perc = float(charge_now) / float(charge_full)
            elif energy_now and energy_full and \
                    (power_now or current_now and voltage_now):
                perc = float(energy_now) / float(energy_full)
            else:
                perc = 0

            if power_now:
                power = float(power_now) / 10**6
            elif voltage_now and current_now:
                power = float(current_now) * float(voltage_now) / 10**12
            elif current_now:
                current = float(current_now) / 10**6
            if status == 'charging':
                if time_to_full_now:
                    time = time_to_full_now
                else:
                    time = 0
            elif status == 'discharging' and time_to_empty_now:
                time = time_to_empty_now
                time_to_empty_now

        fmts = {
            'perc': perc
        }
        return self.fmtstr.format_map(fmts)


class CPU:
    def __init__(self, fmt="{perc}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt
        self.idle_old = 0
        self.total_old = 0

    def run(self):
        for line in open("/proc/stat"):
            if line.split()[0] == "cpu":
                cols = [float(c) for c in line.split()[1:]]
                idle = cols[3] + cols[4]
                total = sum(cols)
                break

        try:
            diff_idle = idle - self.idle_old
            diff_total = total - self.total_old
            perc = (1 - diff_idle / diff_total) * 100
        except (ZeroDivisionError, KeyError):
            perc = 0

        self.idle_old = idle
        self.total_old = total
        fmts = {
            'cpu_idle': idle,
            'cpu_total': total,
            'perc': perc
        }
        return self.fmtstr.format_map(fmts)


class Date:
    def __init__(self, fmt="{date}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt

    def run(self):
        fmts = {'date': time.strftime("%a %b %d %H:%M:%S")}
        return self.fmtstr.format_map(fmts)


class Memory:
    def __init__(self, fmt="{perc}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt

    def run(self):
        meminfo = [line.split(':') for line in open('/proc/meminfo')]
        mem = {k: int(v.strip().split()[0]) for k, v in meminfo}
        fmts = {
            'used': mem['MemTotal'] - mem['MemAvailable'],
            'total': mem['MemTotal'],
            'perc': 100 * (mem['MemTotal'] - mem['MemAvailable']) / mem['MemTotal'],
            'swap_used': mem['SwapTotal'] - mem['SwapFree'],
            'swap_total': mem['SwapTotal'],
            'swap_perc': 100 * (mem['SwapTotal'] - mem['SwapFree']) / mem['SwapTotal']
        }
        return self.fmtstr.format_map(fmts)


class Mpd:
    def __init__(self, fmt="{status}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt
        self.mpdclient = MPDClient()
        self.mpdclient.connect("localhost", 6600)

    def run(self):
        currentsong = self.mpdclient.currentsong()
        status = self.mpdclient.status()
        fmts = {
            'song': currentsong.get('file', ''),
            'time': float(currentsong.get('time', 0)),
            'elapsed': float(status.get('elapsed', 0)),
            'status': status.get('state', '')
        }
        return self.fmtstr.format_map(fmts)


class Power:
    def __init__(self, fmt="{power}", icons=[], interval=1):
        self.interval = interval
        self.fmtstr = fmt

    def run(self):
        for status in glob.glob("/sys/class/power_supply/A*/online"):
            if open(status).readline().strip() == '1':
                fmts = {'power': 1}
                break

        return self.fmtstr.format_map(fmts)


segments = {
    'notification': '󰂞',
    'exec': '󰣖',
    'apps': '󰍉',
    'mpd': '󰝚',
    'brightness': '󰃟',
    'mail': '󰇰',
    'memory': '󰍛',
    'cpu': '󰓅',
    'play': ['󰏤', '󰐊', '󰓛']
}


if __name__ == '__main__':
    with open('/tmp/status.pid', 'w') as pidfile:
        pidfile.write(str(os.getpid()))

    status = Status2([
        ALSA(),
        Backlight(),
        Battery(),
        CPU(),
        Date(icons=["󰃰"]),
        Memory(),
        Mpd(),
        Power(),
    ])

#     for sig in range(signal.SIGRTMIN, signal.SIGRTMAX + 1):
#         signal.signal(sig, stat.handler)

    while not status.stopped.is_set():
        time.sleep(1)
        status.show()

    os.remove("/tmp/status.pid")
